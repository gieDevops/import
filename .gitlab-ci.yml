# Enable Merge Request Pipeline
workflow: &workflow_mr
  rules:
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# CI/CD Variables
variables:
  ARGOCD_IMAGE_VERSION: 'v2.3.3'
  CI_APPLICATION_IMAGE: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG
  ARGOCD_REVIEW_APPLICATION_NAME: $CI_PROJECT_NAME-$CI_MERGE_REQUEST_IID
  ARGOCD_PROD_APPLICATION_NAME: $CI_PROJECT_NAME
  
# List of stages for jobs, and their order of execution 
stages:
  - build
  - review
  - cleanup
  - production

docker-build:
  # Use the official docker image.
  image: docker:latest
  stage: build
  services:
    - docker:dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  # Default branch leaves tag empty (= latest tag)
  # All other branches are tagged with the escaped branch name (commit ref slug)
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA"
  # Run this job in a branch where a Dockerfile exists
  rules:
    - exists:
        - Dockerfile

# Update GitOps Configuration
gitops:update-manifests:
  stage: deploy
  image: 
    name: alpine/git:v2.32.0
    entrypoint: ["/bin/sh", "-c"]
  #to remove
  before_script:
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh && chmod 600 ~/.ssh
    - ssh-keyscan -H ${CI_SERVER_HOST} >> ~/.ssh/known_hosts
    - echo "${CONFIGURATION_SSH_PRIVATE_KEY}" |  tr -d ' ' | base64 -d | ssh-add -
    - git config --global user.email "git@gitlabrunner.com"
    - git config --global user.name "Gitlab Runner"
  script:
    - git clone "git@${CI_SERVER_HOST}:${CI_PROJECT_PATH}-configuration" "${CI_COMMIT_SHA}"
    - cd "${CI_COMMIT_SHA}"
    - git checkout "${CI_DEFAULT_BRANCH}"
    - sed -i "s/^\(  tag:\).*$/\1 ${CI_COMMIT_SHA}/g" chart/values-production.yaml
    - git add .
    - |-
      if [ "$(git status --porcelain | wc -l)" -gt "0" ]; then
        git status
        git commit -m "Update the image tag with '${CI_COMMIT_SHA}' (automated by GitLab CI)"
        git push origin "${CI_DEFAULT_BRANCH}" -o ci.skip
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

#Argo CD Deployment
.argocd:
  image: "argoproj/argocd:${ARGOCD_IMAGE_VERSION}"
  before_script:
    - argocd login ${ARGOCD_SERVER_URL} --insecure --grpc-web --username ${ARGOCD_USERNAME} --password ${ARGOCD_PASSWORD}
  dependencies: []

argocd:review:
  extends: .argocd
  stage: review
  script:
    - argocd app sync ${ARGOCD_REVIEW_APPLICATION_NAME}
    - argocd app wait ${ARGOCD_REVIEW_APPLICATION_NAME}
    - echo $CI_ENVIRONMENT_URL >environment_url.txt
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: http://$ARGOCD_REVIEW_APPLICATION_NAME.$KUBE_INGRESS_BASE_DOMAIN
    on_stop: argocd:stop_review
  artifacts:
    paths: [environment_url.txt]
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'

argocd:stop_review:
  extends: .argocd
  stage: cleanup
  script:
    - argocd app delete-resource ${ARGOCD_REVIEW_APPLICATION_NAME} --kind Deployment
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: manual

argocd:production:
  extends: .argocd
  stage: production
  script:
    - argocd app sync ${ARGOCD_PROD_APPLICATION_NAME}
    - argocd app wait ${ARGOCD_PROD_APPLICATION_NAME}
  environment:
    name: production
    url: https://${ARGOCD_PROD_APPLICATION_NAME}-prod.${KUBE_INGRESS_BASE_DOMAIN}
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

